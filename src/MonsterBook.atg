#include <string>
#include <map>
#include "Symbol.h"
#include "Function.h"

COMPILER MonsterBook

double m_dResult;
std::map<std::string, Symbol*> m_oSymbolTable;

Symbol* addSymbol(const std::string& name, EnDataType type, EnSymbolKind kind, void* adr)
{
	if(findSymbol(name) == nullptr)
	{
		Symbol* pSymbol = new Symbol();
		pSymbol->name = name;
		pSymbol->type = type;
		pSymbol->kind = kind;
		pSymbol->adr = adr;
		m_oSymbolTable.insert(std::make_pair(name, pSymbol));
		return pSymbol;
	}
	else
		return nullptr;
}

Symbol* findSymbol(const std::string& name)
{
	auto itr = m_oSymbolTable.find(name);
	if(itr == m_oSymbolTable.end())
		return nullptr;
	else
		return itr->second;

}

CHARACTERS
digit = "0123456789".
letter = 'a'..'z'+'A'..'Z'.

TOKENS
ident = letter{digit|letter}.
number = digit{digit}['.'{digit}].

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\r'

IGNORE '\t' + '\r' + '\n'

PRODUCTIONS
MonsterBook = Expr<m_dResult>.
Expr<double& dVal> = (. double dV1; .) 
    Term<dV1> 
    {
        '+' (. double dV2; .) Term<dV2> (. dV1 += dV2; .)
        | 
        '-' (. double dV2; .) Term<dV2> (. dV1 -= dV2; .)
    } (. dVal = dV1; .). 
Term<double& dVal> = 
    Factor<dVal>
    { 
        '*' (. double dV2; .) Factor<dV2> (. dVal *= dV2; .)
        | 
        '/' (. double dV2; .) Factor<dV2> (. dVal /= dV2; .)
    }.
Factor<double& dVal> = 
    number (. dVal = std::stod(t->val); .)
    | '-' number (. dVal = - std::stod(t->val); .)
	| ident 
		(. 
			auto pSymbol = findSymbol(coco_string_create_char(t->val));
            if (pSymbol)
            {
                if (la->val[0] != '(')
                {
                    if (pSymbol->kind == skVar && pSymbol->type == dtDouble)
                    {
                        dVal = *((double*)pSymbol->adr);
                    }
                    else
                    {
                        std::wstring str = L"Symbol " + std::wstring(t->val) + L" not double var!";
                        errors->Exception(str.c_str());
                    }
                }
            }
            else
            {
                std::wstring str = L"Symbol " + std::wstring(t->val) + L" undefine!";
                errors->Exception(str.c_str());
            }
		.)
	['(' 
		(. 
            if (pSymbol->kind != skFunc)
			{
                std::wstring str = L"Function " + std::wstring(t->val) + L" undefine!";
                errors->Exception(str.c_str());
            }
			double dTemp;
		.)
		Expr<dTemp> 
		(.
			((Function*)pSymbol->adr)->addParam(dTemp);
		.)
		{',' 
		Expr<dTemp>
		(.
			((Function*)pSymbol->adr)->addParam(dTemp);
		.)
		} ')' 
		(.
			dVal = ((Function*)pSymbol->adr)->execute();
		.)
		| "()" 
		(. 
            if (pSymbol->kind == skFunc)
            {
                dVal = ((Function*)pSymbol->adr)->execute();
            }
            else
            {
                std::wstring str = L"Function " + std::wstring(t->val) + L" undefine!";
                errors->Exception(str.c_str());
            }
		.)
	] 
    | '(' Expr<dVal> ')'.

END MonsterBook.